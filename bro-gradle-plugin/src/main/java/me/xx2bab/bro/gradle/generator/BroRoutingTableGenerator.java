package me.xx2bab.bro.gradle.generator;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.File;
import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;

import me.xx2bab.bro.annotations.BroActivity;
import me.xx2bab.bro.annotations.BroApi;
import me.xx2bab.bro.annotations.BroModule;
import me.xx2bab.bro.common.BroProperties;
import me.xx2bab.bro.common.Constants;
import me.xx2bab.bro.common.IBroGenerator;
import me.xx2bab.bro.common.IBroRoutingTable2;
import me.xx2bab.bro.common.anno.AnnotatedElement;

public class BroRoutingTableGenerator implements IBroGenerator<List<AnnotatedElement>> {

    private List<Class<? extends Annotation>> supportedAnnotations;
    private HashSet<String> nicks;

    public BroRoutingTableGenerator() {
        supportedAnnotations = new ArrayList<>();
        supportedAnnotations.add(BroActivity.class);
        supportedAnnotations.add(BroApi.class);
        supportedAnnotations.add(BroModule.class);
        nicks = new HashSet<>();
    }

    @Override
    public void onGenerate(List<AnnotatedElement> metaDataList,
                           String appPackageName,
                           File appAptGenDirectory,
                           File broBuildDirectory) {
        nicks.clear();


    }

    /**
     * Step 3 :
     * <p>
     * Generates all map file with temp-json by other module in app-module's build path
     *
     * @param filer       filer tools
     * @param existFile   exist file generated by processor.init()
     */
    public void generateRoutingTable(List<AnnotatedElement> metaDataList,
                                     Filer filer, File existFile) {
        try {
            TypeSpec.Builder builder = TypeSpec.classBuilder(Constants.ROUTING_TABLE_FILE_NAME)
                    .addModifiers(Modifier.PUBLIC)
                    .addSuperinterface(IBroRoutingTable2.class);

//            for (Map.Entry<String, Map<String, BroProperties>> entry : exposeMaps.entrySet()) {
//                builder.addMethod(generateMapMethod("get" + entry.getKey() + "Map", entry.getValue()));
//            }

            JavaFile file = JavaFile.builder(Constants.ROUTING_TABLE_PACKAGE_NAME, builder.build())
                    .addFileComment("Generated by Bro.").build();

            if (existFile == null) {
                // standard output
                file.writeTo(filer);
            } else {
                // hack file override exception
                File folder = existFile.getParentFile();
                int times = file.toJavaFileObject().toUri().toString().split("/").length;
                for (int i = 1; i < times; i++) {
                    folder = folder.getParentFile();
                }
                file.writeTo(folder);
            }

        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    private MethodSpec generateMapMethod(String methodName, Map<String, BroProperties> map) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName)
                .addModifiers(Modifier.PUBLIC)
                .returns(ParameterizedTypeName.get(HashMap.class, String.class, BroProperties.class))
                .addStatement("HashMap<String, BroProperties> map = new HashMap<String, BroProperties>()");

        // keep the order
        Map<String, BroProperties> orderMap = new TreeMap<>(map);
        Set<Map.Entry<String, BroProperties>> set = orderMap.entrySet();
        for (Map.Entry<String, BroProperties> entry : set) {
            builder.addStatement("map.put(\"" + entry.getKey() + "\", new BroProperties(\""
                    + entry.getValue().clazz + "\", $S" + "))", entry.getValue().extraParams);
        }
        builder.addStatement("return map");
        return builder.build();
    }

    /**
     * Avoid duplicated nick.
     *
     * @param nick A value in Bro Annotations that can be used to get the real reference of
     *             the specific class.
     * @throws DuplicatedNickException We don't allow duplicated nicks so we throw a custom exp.
     */
    private void checkDuplicatedNick(String nick) throws DuplicatedNickException {
        if (nicks.contains(nick)) {
            throw new DuplicatedNickException("BroRoutingTableGenerator: Nick \"" + nick + "\" is" +
                    " duplicated, please check annotation values!");
        }
        nicks.add(nick);
    }

    public File findCurrentAptGenFolder(String fileName, File node) {
        if (node.getName().equals("androidTest")) { // filter some folders
            return null;
        }
        if (node.isDirectory()) {
            File[] subFiles = node.listFiles();
            List<String> subFileNames = Arrays.asList(node.list());

            if (subFiles == null) {
                return null;
            }
            if (subFileNames.contains(fileName)) {
                File target = new File(node.getAbsolutePath() + File.separator + fileName);
                if (!target.isDirectory()) {
                    return target;
                }
            }

            for (File f : subFiles) {
                File file = findCurrentAptGenFolder(fileName, f);
                if (file != null) {
                    return file;
                }
            }

            return null;
        }
        return null;
    }


    private class DuplicatedNickException extends Exception {
        private DuplicatedNickException(String s) {
            super(s);
        }
    }

}
