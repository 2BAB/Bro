package me.xx2bab.bro.gradle.processor

import com.alibaba.fastjson.JSON
import com.alibaba.fastjson.JSONObject
import com.squareup.javapoet.*
import me.xx2bab.bro.annotations.BroApi
import me.xx2bab.bro.common.Constants
import me.xx2bab.bro.common.IBroApi
import me.xx2bab.bro.common.gen.GenOutputs
import me.xx2bab.bro.common.gen.anno.IBroAnnoProcessor
import me.xx2bab.bro.common.gen.anno.IBroApiInterfaceAndAliasMap
import me.xx2bab.bro.common.util.FileUtils
import net.steppschuh.markdowngenerator.table.Table
import net.steppschuh.markdowngenerator.text.heading.Heading
import java.util.*
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.AnnotationMirror
import javax.lang.model.element.Element
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement

/**
 * To process the "BroApi.class" annotation and generate [Interface, Alias] map file.
 */
class BroApiInterfaceAndAliasMapAnnoProcessor : IBroAnnoProcessor {


    companion object {
        private val BRO_API_CLASS = BroApi::class.java.canonicalName
        private val TYPE_STRING_AND_STRING_MAP: TypeName = ParameterizedTypeName
                .get(MutableMap::class.java, String::class.java, String::class.java)
        private val TYPE_STRING_AND_STRING_HASHMAP: TypeName = ParameterizedTypeName
                .get(HashMap::class.java, String::class.java, String::class.java)
        private const val FIELD_MAP = "interfaceAliasMap"
    }

    override fun getSupportedAnnotationTypes(): Collection<Class<out Annotation?>> {
        val set: MutableSet<Class<out Annotation?>> = HashSet()
        set.add(BroApi::class.java)
        return set
    }

    override fun onCollect(element: Element, processingEnvironment: ProcessingEnvironment): String {
        if (element !is TypeElement) {
            return ""
        }
        if (!containBroApi(element.annotationMirrors)) {
            return ""
        }
        val alias = parseClassAlias(element)
        if (alias == null || alias.isEmpty()) {
            return ""
        }
        val interfaze = parseApiInterface(element, processingEnvironment)
        if (interfaze == null || interfaze.isEmpty()) {
            return ""
        }
        val jsonObject = JSONObject()
        jsonObject[interfaze] = alias
        return jsonObject.toJSONString()
    }

    override fun onGenerate(inputMetaData: List<String>,
                            genOutputs: GenOutputs,
                            processingEnvironment: ProcessingEnvironment) {
        // Extract ClassAlias<->Interface map
        val interfaceAliasMap: MutableMap<String, String> = mutableMapOf()
        for (s in inputMetaData) {
            val jsonObject = JSON.parseObject(s)
            for (key in jsonObject.keys) {
                interfaceAliasMap[key] = jsonObject.getString(key)
            }
        }
        // Generate to the java file
        val className = GenOutputs.generateClassNameForImplementation(
                IBroApiInterfaceAndAliasMap::class.java)
        val builder = TypeSpec.classBuilder(className)
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(IBroApiInterfaceAndAliasMap::class.java)
        builder.addField(TYPE_STRING_AND_STRING_MAP, FIELD_MAP,
                Modifier.PRIVATE, Modifier.FINAL)
        builder.addMethod(generateConstructor(interfaceAliasMap))
        builder.addMethod(generateGetAliasByInterfaceMethod())
        val file = JavaFile.builder(Constants.GEN_PACKAGE_NAME, builder.build())
                .indent("    ") // with 4 spaces
                .addFileComment("Generated by BroRoutingTableAnnoProcessor.").build()
        try {
            file.writeTo(processingEnvironment.filer)
        } catch (e: Exception) {
            e.printStackTrace()
        }
        // Generate the doc
        generateDoc(interfaceAliasMap, genOutputs)
    }

    private fun containBroApi(collection: Collection<AnnotationMirror>): Boolean {
        for (anno in collection) {
            if (anno.annotationType.toString() == BRO_API_CLASS) {
                return true
            }
        }
        return false
    }

    private fun parseClassAlias(element: TypeElement): String? {
        val collection: Collection<AnnotationMirror> = element.annotationMirrors
        for (anno in collection) {
            if (anno.annotationType.toString() == BRO_API_CLASS) {
                for (key in anno.elementValues.keys) {
                    if (key.simpleName.contentEquals("alias")) {
                        return anno.elementValues[key].toString()
                    }
                }
                return element.asType().toString()
            }
        }
        return null
    }

    private fun parseApiInterface(element: TypeElement, pe: ProcessingEnvironment): String? {
        for (mirror in element.interfaces) {
            val result = parseApiInterfaceInternal(mirror.toString(), pe)
            if (result != null) {
                return mirror.toString()
            }
        }
        return null
    }

    private fun parseApiInterfaceInternal(interfaceCanonicalName: String,
                                          pe: ProcessingEnvironment): String? {
        val typeElement = pe.elementUtils.getTypeElement(interfaceCanonicalName)
        if (typeElement != null && typeElement.interfaces.size > 0) {
            val interfaces = typeElement.interfaces
            for (childInterface in interfaces) {
                if (childInterface.toString() == IBroApi::class.java.canonicalName) {
                    return typeElement.toString()
                }
                val childResult = parseApiInterfaceInternal(childInterface.toString(), pe)
                if (childResult != null) {
                    return childResult
                }
            }
        }
        return null
    }

    private fun generateConstructor(interfaceAliasMap: Map<String, String>): MethodSpec {
        val builder = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addCode(CodeBlock.builder().addStatement("$FIELD_MAP = new \$T()",
                        TYPE_STRING_AND_STRING_HASHMAP).build())
        for (key in interfaceAliasMap.keys) {
            builder.addStatement(FIELD_MAP + ".put(\"" + key + "\", \""
                    + interfaceAliasMap[key] + "\")")
        }
        return builder.build()
    }

    /**
     * Implements the #getAliasByInterface(String interfaze) method
     * from IBroApiInterfaceAndAliasMap.class.
     *
     * @return The MethodSpec object used by JavaPoet.
     */
    private fun generateGetAliasByInterfaceMethod(): MethodSpec {
        val param = "interfaze"
        return MethodSpec.methodBuilder("getAliasByInterface")
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(Override::class.java)
                .addParameter(String::class.java, param)
                .returns(String::class.java)
                .addStatement("return $FIELD_MAP.get($param)")
                .build()
    }

    private fun generateDoc(interfaceAliasMap: Map<String, String>, genOutputs: GenOutputs) {
        val builder = StringBuilder()
        builder.append(Heading("Map of [Interface -> Alias]", 1)).append("\n\n\n")
        builder.append(Heading("Local Interface", 2)).append("\n\n")
        val localInterfaceTable = Table.Builder()
                .withAlignments(Table.ALIGN_LEFT, Table.ALIGN_LEFT)
                .addRow("Interface", "Alias")
        for (key in interfaceAliasMap.keys) {
            localInterfaceTable.addRow(key, interfaceAliasMap[key])
        }
        builder.append(localInterfaceTable.build())
        FileUtils.default.writeFile(builder.toString(),
                genOutputs.broBuildDirectory.absolutePath, "bro-intf-alias-map.md")
    }

}