package me.xx2bab.bro.compiler.collector;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;

import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.processing.ProcessingEnvironment;

import me.xx2bab.bro.common.Constants;
import me.xx2bab.bro.common.gen.GenOutputs;
import me.xx2bab.bro.common.gen.anno.IBroAnnoProcessor;
import me.xx2bab.bro.common.util.FileUtils;
import me.xx2bab.bro.compiler.util.BroCompileLogger;

/**
 * To collect all meta data json files that generated by SingleModuleCollector,
 * and expose them to generators.
 *
 * @see SingleModuleCollector
 * @see IBroAnnoProcessor
 */
public class MultiModuleCollector {

    private List<IBroAnnoProcessor> processors;
    private ProcessingEnvironment processingEnvironment;
    private FileUtils fileUtils;
    private GenOutputs genOutputs;

    private Map<String, List<String>> map;

    public MultiModuleCollector(List<IBroAnnoProcessor> processors,
                                ProcessingEnvironment processingEnvironment,
                                FileUtils fileUtils,
                                GenOutputs genOutputs) {
        this.processors = processors;
        this.processingEnvironment = processingEnvironment;
        this.fileUtils = fileUtils;
        this.genOutputs = genOutputs;

        map = new HashMap<>();
        for (IBroAnnoProcessor processor : processors) {
            map.put(processor.getClass().getCanonicalName(), new ArrayList<String>());
        }
    }

    public void addMetaRecord(Map<String, List<String>> singleModuleMetaData) {
        if (singleModuleMetaData == null || singleModuleMetaData.isEmpty()) {
            return;
        }
        for (String key : singleModuleMetaData.keySet()) {
            map.get(key).addAll(singleModuleMetaData.get(key));
        }
    }
    
    public void generate() {
        if (processors == null) {
            return;
        }
        for (IBroAnnoProcessor processor : processors) {
            List<String> res = map.get(processor.getClass().getCanonicalName());
            res.sort(new Comparator<String>() {
                @Override
                public int compare(String t1, String t2) {
                    return t1.compareTo(t2);
                }
            });
            processor.onGenerate(res,
                    genOutputs,
                    processingEnvironment);
        }
    }

    /**
     * To load all bro intermediate files that SingleModuleCollector generated on last step.
     *
     * @param inputPaths A String composited by several directory paths that may contain
     *                   bro intermediates.
     * @see Constants#MODULE_META_INFO_FILE_SUFFIX
     * @see Constants#ANNO_PROC_ARG_LIB_META_DATA_OUTPUT_PATH
     * @see Constants#ANNO_PROC_ARG_APP_META_DATA_INPUT_PATH
     */
    public void load(String inputPaths) {
        String[] splitPaths = inputPaths.split(";");
        for (String path : splitPaths) {
            File file = new File(path);
            if (!file.exists() || !file.isDirectory()) {
                continue;
            }
            File[] childFiles = file.listFiles();
            if (childFiles == null || childFiles.length == 0) {
                continue;
            }

            // Traverse all bro intermediates that file name ends with MODULE_META_INFO_FILE_SUFFIX
            for (File child : childFiles) {
                BroCompileLogger.i("Processing meta data file: " + child.getName());
                if (!child.getName().endsWith(Constants.MODULE_META_INFO_FILE_SUFFIX)) {
                    continue;
                }

                String json = fileUtils.readFile(child);
                if (json == null) {
                    continue;
                }
                JSONObject mapJsonObj = JSON.parseObject(json);
                for (String key : mapJsonObj.keySet()) {
                    String valueJson = mapJsonObj.getString(key);
                    List<String> value = JSON.parseArray(valueJson, String.class);

                    // The same action as #addMetaRecord(...)
                    map.get(key).addAll(value);
                }
            }
        }
    }


}
